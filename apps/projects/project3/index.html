<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head><meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>Project 3 - Image Processing - CS6640 - Deepak Antony</title></head>
<body><big><big><big>Project 3 - Image Processing - CS6640</big><br><small>Deepak Antony<br>dab@cs.utah.edu<br>U0561285</small></big></big><br><hr style="width: 100%; height: 2px;"><big><span style="font-weight: bold;">Running the project</span></big><p style="margin-bottom: 0in;">The project was created in
the vispack tree as required and is compiled same way vispack-build
directory is compiled.&nbsp;</p><p style="margin-bottom: 0in;">To
run&nbsp;project3 go to the directory where the executable is and type
./project3 &lt;parameter_file&gt;. The mosaiced image is generated in the specified output file.</p><br>Here's an example of sample run (numbers/words in bold &amp; underlined are user inputs):<br><br><small style="font-style: italic; font-family: Courier New,Courier,monospace;">beast@beast-desktop:~/Desktop/vispack-build/apps/projects/project3$ ./project3 params_vispack_new.txt <br>correspondence matrix <br>4 4<br>0 1 1 1 <br>0 0 0 0 <br>0 0 0 0 <br>0 0 0 0 <br><br>The correspondences between image 0 and image 1 are: <br>c0=(434,6)&nbsp; : c'0=(81,72) <br>c1=(451,136)&nbsp; : c'1=(106,227) <br>c2=(540,125)&nbsp; : c'2=(210,203) <br>c3=(550,21)&nbsp; : c'3=(218,69) <br>c4=(421,110)&nbsp; : c'4=(75,196) <br>c5=(427,243)&nbsp; : c'5=(86,356) <br>c6=(561,245)&nbsp; : c'6=(241,355) <br>c7=(554,110)&nbsp; : c'7=(227,180) <br>c8=(420,23)&nbsp; : c'8=(66,91) <br>c9=(550,23)&nbsp; : c'9=(217,72) <br>c10=(354,246)&nbsp; : c'10=(8,365) <br>c11=(561,246)&nbsp; : c'11=(239,352) <br>c12=(389,131)&nbsp; : c'12=(38,226) <br>c13=(440,230)&nbsp; : c'13=(98,340) <br>c14=(556,112)&nbsp; : c'14=(229,182) <br>c15=(546,230)&nbsp; : c'15=(221,338) <br><br>The correspondences between image 0 and image 2 are: <br>c0=(30,221)&nbsp; : c'0=(174,163) <br>c1=(16,362)&nbsp; : c'1=(155,317) <br>c2=(3,249)&nbsp; : c'2=(140,192) <br>c3=(2,340)&nbsp; : c'3=(139,293) <br>c4=(24,128)&nbsp; : c'4=(164,49) <br>c5=(17,235)&nbsp; : c'5=(159,178) <br>c6=(130,234)&nbsp; : c'6=(287,180) <br>c7=(131,128)&nbsp; : c'7=(291,56) <br>c8=(11,109)&nbsp; : c'8=(148,26) <br>c9=(16,366)&nbsp; : c'9=(155,320) <br>c10=(181,129)&nbsp; : c'10=(349,63) <br>c11=(181,363)&nbsp; : c'11=(337,323) <br>c12=(255,168)&nbsp; : c'12=(429,108) <br>c13=(256,196)&nbsp; : c'13=(428,143) <br>c14=(313,196)&nbsp; : c'14=(488,145) <br>c15=(313,167)&nbsp; : c'15=(489,111) <br><br>The correspondences between image 0 and image 3 are: <br>c0=(134,10)&nbsp; : c'0=(264,105) <br>c1=(231,8)&nbsp; : c'1=(369,84) <br>c2=(132,128)&nbsp; : c'2=(257,252) <br>c3=(231,127)&nbsp; : c'3=(367,239) <br>c4=(13,22)&nbsp; : c'4=(151,143) <br>c5=(12,109)&nbsp; : c'5=(146,241) <br>c6=(148,110)&nbsp; : c'6=(274,228) <br>c7=(149,23)&nbsp; : c'7=(279,120) <br>c8=(256,167)&nbsp; : c'8=(397,293) <br>c9=(256,196)&nbsp; : c'9=(398,332) <br>c10=(313,196)&nbsp; : c'10=(472,329) <br>c11=(313,165)&nbsp; : c'11=(473,287) <br>c12=(25,129)&nbsp; : c'12=(157,261) <br>c13=(36,140)&nbsp; : c'13=(166,274) <br>c14=(121,139)&nbsp; : c'14=(244,266) <br>c15=(131,128)&nbsp; : c'15=(257,251) <br><br>Initializing the transformations<br>Creating perspective transformation from image 0 to image 1<br>Setting up the system Ax = b.<br>b - done<br>Building A<br>A - done<br>Linear system solved.<br>Creating perspective transformation from image 1 to image 0<br>Creating perspective transformation from image 0 to image 2<br>Setting up the system Ax = b.<br>b - done<br>Building A<br>A - done<br>Linear system solved.<br>Creating perspective transformation from image 2 to image 0<br>Creating perspective transformation from image 0 to image 3<br>Setting up the system Ax = b.<br>b - done<br>Building A<br>A - done<br>Linear system solved.<br>Creating perspective transformation from image 3 to image 0<br>Done setting up transformations from the initial values<br>Calling dijkstras<br>Dijkstras Initialization.<br>Dijkstras main loop.<br>Done with executing dijkstras algorithm<br>Shortest paths array: 1 -1 0 0 <br>Done initializing the required transformations.<br>Starting contrast correction<br>Ending contrast correction<br>Finding the image size....<br>MinX: -472<br>MinY: -3<br>MaxX: 575<br>MaxY: 592<br>Mosaiced image written to mosaic_out_stest.tif<br></small><br><br><big><span style="font-weight: bold;">Code organization</span></big><br><ul><li>transform.h
and transform.cxx contains transformation classes used for image
mosaicing. Also contains the cascading class, which cascades more than
one transformations.</li><li>project3.cxx contains the class
ImageMosaic. The constructor of the image mosaic takes in the parameter
file name. All the initialization and construction of the mosaiced
image is done here. initTransformations() and computeMosaic() are main
functions in this class. The algorithm is described below.</li></ul><br><span style="font-weight: bold;">Other</span><br><br>- The correspondences for my own images were identified using the tool, Hugin.<br>- The utah capitol image was found in google search.<br>- The panoromic image is the view from my balcony.<br>-
I've put the parameter files i've used in the folder
"parameterfiles_executable". It also contains the executable and the
input images.<hr style="width: 100%; height: 2px;"><big><span style="font-weight: bold;">Implementation (Algorithm)<br></span></big><hr style="width: 100%; height: 2px;"><span style="font-weight: bold;"></span><span style="font-weight: bold;"></span><span style="font-weight: bold; text-decoration: underline;"></span><span style="font-weight: bold;"></span>The algorithm is mainly the following steps:<br>1. Setup the correspondences and correspondence matrix.<br>2. Initialize the transformations<br>3. Construct transformations to the target image<br>4. Perform contrast correction<br>5. Identify the bounding box<br>6. Resample, interpolate, perform feathering and construct the final image.<br><br><span style="font-weight: bold;">Setting up the Correspondences and correspondence matrix</span><br><br>I
used Hugin to generate control points(for the panaromic image I had to
identify them manually). Since this is a GUI based application, its
easy to identify the control points. I manually enter these control
points into the parameter file. The code to read the parameter file was
already given to us and I'm using the same. This sets up the
correspondences and the correspondence matrix.<br><br><span style="font-weight: bold;">Initialize the transformation</span><br><br>In
this part I identify the correspondences that&nbsp;exist and create the
perspective transformations for those. For the inverse transformations,
I found that the results are better when you use calculated Inverse
than to use the new transformation calculated by reversing the
correspondences and solving for x again. The first part of the
initTransformations() performs this functionality.<br><br>Note:
Although there is a class InversePerspective to handle the inverse
transformation, I use the class Perspective even for inverse
transformation as the class WarpType could not take 2 type of classes,
even when I use just Transform and it was just small addition of code
in class Perspective to do both work.<br><br><span style="font-weight: bold;">Construct transformations to the target image (cascading)</span><br><br>This
is basically cascading the existing transformations. We need to do this
since we need transformations from and to target images domain. To do
this I use dijkstra's shortest path algorithm with the target image as
the source. This gives me the path to every other from the target
image. This enables me to go back and forth from any image space to the
domain of target image. <br><br>Dijkstra's algorithm is implemented in dijkstras() function and the cascading is done in the last part of initTransformations().<br><br><span style="font-weight: bold;">Perform contrast correction</span><br><br>To
componsate for different contrasts in images (happens because of
different exposures of the camera) we do the contrast correction. The
idea here is to find the overlapping regions between images,
identifying the mean intensity and adding/subtracting the difference of
the mean between the images to one of the images (if one image has
already been through contrast correction, that image will not again
have its contrast corrected but the other image is corrected to match
it).<br><br>This is implemented in correctContrast() function.<br><br><span style="font-weight: bold;">Identify bounding box<br><br></span>I
take the transformation of the corners of each image and find the
minimum and maximum extent of the composite images, push them to
positive and we have the final image size. This is implemented in
initFinalImageSize().<br><br><span style="font-weight: bold;">Resample, interpolate, perform feathering and construct the final image</span><br><br>For
this I loop through each pixel in the final image and perform an
inverse transform. The final image gets the interpolated intensity
value for that image. For the overlapping regions, since we have
multiple intensities affecting a pixel in the target image's domain, we
can either average the intensity values or perform feathering.
Feathering removes the seams from the composite image. The idea here is
to weigh the different intensities by how far it is from the center of
the image and then assign the weighted average of these intensities. I
have implemented an euclidean distance method, whereas you can have any
distance function (block/chessboard). <br><br>The compositing of the images is implemented in computeMosaic() function.<br><br><span style="font-weight: bold;"></span><span style="font-weight: bold;"></span><hr style="width: 100%; height: 2px;"><span style="font-weight: bold;"><big>Experiments with the algorithm</big><br></span><hr style="width: 100%; height: 2px;">These are the given example images<br><br><img style="width: 576px; height: 432px;" alt="" src="images/w0.png"><img style="width: 576px; height: 432px;" alt="" src="images/w1.png"><img style="width: 496px; height: 401px;" alt="" src="images/w2c.png"><img style="width: 481px; height: 352px;" alt="" src="images/w3c.png"><br><br>Here's the mosaiced image with different target image:<br><br>1. View from image 0 with 16 correspondences<br><img style="width: 1011px; height: 599px;" alt="" src="images/mosaic_out_final_0V_16.png"><br><br>2. View from image 1 with 16 correspondences<br><img style="width: 1047px; height: 595px;" alt="" src="images/mosaic_out_final_1V_16.png"><br><br>3. View from image 2 with 16 correspondences<br><img style="width: 1158px; height: 769px;" alt="" src="images/mosaic_out_final_2V_16.png"><br><br>4. View from image 3 with 16 correspondences<br><img style="width: 1728px; height: 970px;" alt="" src="images/mosaic_out_final_3V_16.png"><br><br><span style="font-weight: bold;">Planar image</span><br><br>I took the image of the utah state capitol and split it with gimp. Here are the split images.<br><br><img style="width: 450px; height: 504px;" alt="" src="images/SC_0.png"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <img style="width: 335px; height: 455px;" alt="" src="images/SC_1.png"><br><br>Here's the composite of these images with 11 correspondences. I used Hugin to identify the control points.<br><br>1. view from image 0 with 11 correspondences<br><img style="width: 642px; height: 503px;" alt="" src="images/mosaic_out_0V_11.png"><br><br>2. view from image 1 with 11 correspondences<br><img style="width: 643px; height: 506px;" alt="" src="images/mosaic_out_1V_11.png"><br><br><span style="font-weight: bold;">Panoramic image</span><br><br>I took the picture of my balcony trying not to move as much as possible and got the images below.<br><img style="width: 600px; height: 450px;" alt="" src="images/STA_0215.png"> &nbsp; <img style="width: 600px; height: 450px;" alt="" src="images/STB_0216.png"> &nbsp; <img style="width: 600px; height: 450px;" alt="" src="images/STC_0217.png"><br><br>Below are the mosaiced image of the above images. I used Hugin to identify the control points.<br><br>1.  view from image 0 with 13 correspondences<br><img style="width: 2127px; height: 1019px;" alt="" src="images/mosaic_out_0V_13.png"><br><br>2.  view from image 1 with 13 correspondences<br><img style="width: 1603px; height: 609px;" alt="" src="images/mosaic_out_1V_13.png"><br><br>3.  view from image 2 with 13 correspondences<br><img style="width: 2557px; height: 1176px;" alt="" src="images/mosaic_out_2V_13.png"><br><br><span style="font-weight: bold;">Feathering</span><br><br>Feathering
blends one image seamlessly on to the other. Here's the mosaic without
feathering followed by the mosaic with feathering. We can see that the
seams we see in the first image have reduced considerably in the second.<br><br>1. view from image 0 with 16 correspondences (no feathering)<br><img style="width: 1011px; height: 599px;" alt="" src="images/mosaic_out_final_0V_16_NF.png"><br><br>2. view from image 0 with 16 correspondences (with feathering)<br><img style="width: 1011px; height: 599px;" alt="" src="images/mosaic_out_final_0V_16.png"><br><br><span style="font-weight: bold;">Contrast correction</span><br><br>Contrast
correction is required to minimize the contrast differences because of
different exposure levels of the camera while taking different images
used in the same panorama.&nbsp;I reduced the contrast of one of the
images and applied the algorithm with and without contrast correction.
Below are the results.<br><br>1. Here's the contrast reduced image (this is the image 0 from the example set)<br><img style="width: 576px; height: 432px;" alt="" src="images/w0CC.png"><br><br>2.
Here's the mosaiced image without contrast correction. We can clearly
see that contrasts of the images differ too much to get a smooth image
with just feathering.<br><img style="width: 1011px; height: 599px;" alt="" src="images/mosaic_out_noCC_0V_16.png"><br><br>3. Here's the mosaiced image with contrast correction. The image is smooth, without ghost effects.<br><img style="width: 1011px; height: 599px;" alt="" src="images/mosaic_out_CC_0V_16.png"><br><br><span style="font-weight: bold;">Theoretical minimum correspondences</span><br><br>Theoretically
we need atleast 4 correspondences to solve for the perspective
projection. Here's how the example set's images composite with just 4
correspondences. We can see that images are distorted, blurred and have
ghost effects.<br><br>1. view from image 0 with 4 correspondences<br><img style="width: 977px; height: 601px;" alt="" src="images/mosaic_out_final_0V_4cp.png"><br><br>2. view from image 1 with 4 correspondences<br><img style="width: 1030px; height: 581px;" alt="" src="images/mosaic_out_final_1V_4cp.png"><br><br>3. view from image 2 with 4 correspondences<br><img style="width: 1231px; height: 1030px;" alt="" src="images/mosaic_out_final_2V_4cp.png"><br><br>4. view from image 3 with 4 correspondences<br><img style="width: 1397px; height: 803px;" alt="" src="images/mosaic_out_final_3V_4cp.png"><br><br><span style="font-weight: bold;">Minimum control points required for good composite</span><br><br>By
experimenting with different number of control points, I found that we
need atleast 7 correspondences for the example set given. I've even put
up the image with just 6 correspondences.<br><br>1. view from image 0 with 7 correspondences<br><img style="width: 1001px; height: 624px;" alt="" src="images/mosaic_out_final_0V_7cp.png"><br><br>2. view from image 0 with 6 correspondences. We see ghosting when I use 6 correspondences.<br><img style="width: 992px; height: 614px;" alt="" src="images/mosaic_out_final_0V_6cp.png"><br><br>3. view from image 1 with 7 correspondences<br><img style="width: 1009px; height: 611px;" alt="" src="images/mosaic_out_final_1V_7cp.png"><br><br>4. view from image 2 with 7 correspondences<br><img style="width: 1106px; height: 847px;" alt="" src="images/mosaic_out_final_2V_7cp.png"><br><br>5. view from image 3 with 7 correspondences<br><img style="width: 1603px; height: 928px;" alt="" src="images/mosaic_out_final_3V_7cp.png"><br><br><br><span style="font-weight: bold;">Error in correspondences</span><br><br>For
identifying the effects of error in correspondences, I tried 2 things.
First I induced error with only 7 correspondences and then with 16
correspondences. We can see that as the number of correspondences
increase the effect of error is diminished. Lesser the correspondences
more errors in the final image when there is an error in the
correspondence. For all the cases I've only changed one correspondence.<br><br>1. No errors, view from image 0 with 7 correspondences.<br><img style="width: 1001px; height: 624px;" alt="" src="images/mosaic_out_final_0V_7cp.png"><br><br>2. 10 errors, view from image 0 with 7 correspondences.<br><img style="width: 1001px; height: 640px;" alt="" src="images/mosaic_out_final_0V_7cp_err10.png"><br><br>3. 20 errors, view from image 0 with 7 correspondences.<br><img style="width: 1001px; height: 652px;" alt="" src="images/mosaic_out_final_0V_7cp_err20.png"><br><br>4. 30 errors, view from image 0 with 7 correspondences.<br><img style="width: 1011px; height: 597px;" alt="" src="images/mosaic_out_final_0V_16_err30.png"><br><br>5. No errors, view from image 0 with 16 correspondences.<br><img style="width: 1011px; height: 599px;" alt="" src="images/mosaic_out_final_0V_16.png"><br><br>6. 10 errors, view from image 0 with 16 correspondences.<br><img style="width: 1011px; height: 598px;" alt="" src="images/mosaic_out_final_0V_16_err10.png"><br><br>7. 20 errors, view from image 0 with 16 correspondences.<br><img style="width: 1011px; height: 599px;" alt="" src="images/mosaic_out_final_0V_16_err20.png"><br><br>8. 30 errors, view from image 0 with 16 correspondences.<br><img style="width: 1011px; height: 597px;" alt="" src="images/mosaic_out_final_0V_16_err30.png"><br><br><hr style="width: 100%; height: 2px;"><p style="margin-bottom: 0in;"><span style="font-weight: bold;">Reference</span></p><p style="margin-bottom: 0in;">Digital Image Processing, Gonzalez &amp; Woods<br>Panoramic Image Mosaics, Shum and Szeliski<br>An introdunction to image mosaicing, Sevket Gumustekin</p></body></html>