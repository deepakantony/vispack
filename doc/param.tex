% $Id: param.tex,v 1.1.1.1 2003-02-12 16:51:11 whitaker Exp $
% Josh Cates 03/23/00
% Documentation for vispack param.h and param.C
\documentclass{article}

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\Asymbol}[1]{\mathit{\mathbf{#1}}}

\setlength{\topmargin}{0in}
\setlength{\textwidth}{5.75in}
\setlength{\textheight}{8.0in}
\setlength{\oddsidemargin}{0.5in}
\pagestyle{plain}

\title{Parameter files and objects}
\author{Josh Cates}
\date{13 March 2000}
\begin{document}

\maketitle

\paragraph{Introduction}
When implementing algorithms, it is often the case that
a significant number of values are needed to initialize various
constants, specify input and output files, or otherwise tune the
performance of the algorithm.  Specifying increasingly more and more
parameter values as command line arguments becomes unwieldy for both
the developer and the user of the software.  The \code{ParameterFile} object
is intended to simplify the process by defining a standard file format
for specifying parameters and a simple protocol for reading those files.

This document discusses the \code{ParameterFile} object design and its user 
interface.  Examples are provided.

\paragraph{Implementation}
The \code{ParameterFile} object encapsulates the process of opening, reading,
and parsing a file into the instantiation of a single high level
object with a limited public interface.  The implementation
consists of three components: a token scanner, a parser, and a syntax
tree.  The parser queries the token scanner for input and constructs a
syntax tree of objects whose root node is the \code{ParameterFile} object.

The token scanner (\code{yylex()}) is created using the \code{flex} 
utility, a standard lexical analyzer generator.  The set of tokens $T$,
\[
T = ( \Asymbol{identity}, \Asymbol{string}, \Asymbol{integer}, 
\Asymbol{decimal}, \Asymbol{rparen}, \Asymbol{lparen} )
\]
recognized by the scanner are encoded in the file \code{param.l} as
regular expressions.

The parser is generated with the standard \code{yacc} utility and 
then compiled into a function \code{yyparse()}.  When invoked,
\code{yyparse()} calls \code{yylex()} for input and attempts to
identify syntactic structures of the grammar
$ G\footnote{$G$ is defined in the file \code{param.y}.}  
= \left( V, T, P, \Asymbol{ParameterFile} \right)$
where $V$ is the set of variables, $ V = ( \Asymbol{ParameterFile}, 
\Asymbol{Parameter}, \Asymbol{Value} )$, and $P$ is the set of 
productions:
\[
\begin{array}{l}
\Asymbol{ParameterFile} \Rightarrow \ \Asymbol{Parameter}^{\ast} \\
\Asymbol{Parameter} \Rightarrow \ \Asymbol{lparen}\  \Asymbol{identity}
	\ \Asymbol{Value}^{\ast} \ \Asymbol{rparen}\\
\Asymbol{Value} \Rightarrow \ \left( \ \Asymbol{string} \ | \ 
	\Asymbol{integer} \ | \ \Asymbol{decimal} \ \right)
\end{array}
\]

As productions in the grammar are identified, \code{yyparse()} constructs
a ``syntax tree'' of objects representing those productions. The tree is 
constructed by the parser from the bottom up.  All the objects are
subclassed from a pure virtual \code{VPF::node} object, thereby enabling
run-time polymorphism of node object methods.

\paragraph{Parameter file format}
A parameter file as described by the grammar $G$, is an ASCII text file 
supplying a list of parameters of the form,
\begin{verbatim}

(parameter_name optional_value1 optional_value2 ... optional_valueN)

\end{verbatim}

The parameter naming conventions are similar to C language variable naming
conventions.  A parameter name must begin with an alphanumeric character and
may consist of any of the letters \code{A-Z},\code{a-z}; numbers \code{0-9}; 
and the underscore character \code{\_}.

The optional values may be either integer, decimal, or string values.  Decimal
numbers can be either floating point or  double precision\footnote{Most variants
on these types are also supported (long double, etc).  Check the header files
for a complete list of types supported.}.  A number value lacking a decimal point 
character is assumed to be an integer value.

A string value is specified by enclosing any characters (except the newline and
\code{"} characters) in quotation marks \code{"}.
\begin{verbatim}
(parameter_name "string value number 1.1" "stri%$ng value number 2")
\end{verbatim}

The value types for a parameter can be mixed.  For example,
\begin{verbatim}
(mixed_values  45.23 1 0 2 3234.99999 "string")
\end{verbatim}

C++-style commenting is supported.  C-style commenting is not supported.  All
characters after double forward slashes \code{//} up to a newline character are
ignored.

\paragraph{The \code{ParameterFile} object}
The \code{ParameterFile} object is a ``nice'' object, meaning that the copy
constructor and assignment operators are defined to perform deep copies.
Instances of \code{ParameterFile} objects can be safely passed by reference 
or by value.

A \code{ParameterFile} object can be instantiated with a character string,
a copy constructor, or by assignment,
\begin{verbatim}
	VPF::ParameterFile p1("filename");  // filename
	VPF::ParameterFile p2(p1);	    // copy constructor
	VPF::ParameterFile p3;  p3 = p2;    // assignment
\end{verbatim}
Note the use of the scope resolution operator.  The \code{ParameterFile} objects 
are enclosed in a namespace \code{VISParameterFile} aliased to \code{VPF}.

When instantiated with a character string argument, the constructor attempts to open
and parse the file whose name is represented in the argument, calling
the yyparse() method.  On success, a pointer to the resulting syntax tree is
held in the \code{ParameterFile} object.  
The \code{ParameterFile} object contains the following public methods:

\begin{tabular}[c]{rl}
\ \\
\code{bool valid()} & Returns \code{true} if object contains a valid syntax tree, \\&
\code{false} otherwise.\\
\code{int size()} & Returns the number of parameters contained in the syntax
tree.\\
\code{bool empty()} & Returns \code{true} if the object's valid syntax tree is empty,\\&
\code{false} otherwise.\\
\code{void clear()} & Clears the syntax tree and frees all associated memory.\\
\code{void print()} & Prints a formatted list of everything in the syntax tree
to \\& standard out.  For debugging.
\ \\
\end{tabular}
\newline

The syntax tree of the \code{ParameterFile} object can be thought of as an 
ordered list of \code{Parameter} objects.  The \code{[]} operator has been
overloaded to allow (read) access to the parameters.  Supplying an integer
argument $i$ returns the $i^{\mathit{th}}$ parameter in the list, as ordered in
the input file.  No bounds checking is performed by this operation. Supplying a 
character string argument returns the the parameter whose name matches the argument.  
If no match is found, a ``null parameter'' is returned whose validity is 
\code{false} (see next section).

\paragraph{The \code{Parameter} object}
A \code{Parameter} object is also a ``nice'' object in the sense that it can be 
passed by value or reference and its assignment operator is overloaded.
A \code{Parameter} object has the following methods:

\begin{tabular}[c]{rl}
\ \\
\code{bool valid()} & Returns \code{true} if the parameter is valid, 
\code{false} otherwise.\\
\code{int size()} & Returns the number of values contained in the parameter.\\
\code{bool empty()} & Returns \code{true} if the object's value list is empty,\\ &
 \code{false} otherwise.\\
\code{const char *getName()} & Returns the name of the parameter.\\
\code{void print()} & Prints the parameter name and its values to\\& standard out.  
For debugging.
\ \\
\end{tabular}
\newline

A \code{Parameter} object contains a character string name and an ordered list of 
\code{Value} objects.  The \code{[]} operator has been overloaded to allow (read) 
access to this list. No bounds checking is performed by the \code{[]} operator.
Note that since a \code{Value} object may be of several types, the assigment 
operator cannot be overloaded for the \code{Value} object.  Hence the value 
contained in the object can only be accessed by downcasting to the appropriate
class and using that class's \code{getValue} method (see example section).  The
preferred method for accessing a value is through the overloaded \code{set} method
described in the next section.


\paragraph{The \code{set} method}
The \code{VPF::set} method has been overloaded for all the supported variable types.
It takes as its arguments a variable of the appropriate type and a \code{Value}
object and returns \code{true} if the operation was successful and \code{false}
otherwise.  The declaration of the set method has the following form:
\begin{verbatim}

VPF::bool set(<variable type> &, VPF::Value &)

\end{verbatim}
The method works by first checking the type of the supplied 
\code{Value} object to make sure it is consistant with the requested variable
type.  Then the value contained in the \code{Value} object is cast to the
appropriate type and the assignement is made.

\paragraph{Error handling}
At the time of this writing, C++ exception handling is not used in the
\code{ParameterFile} code.  Some run-time warnings are printed to standard
error and true exceptions such as ``File not found'' result in a call to 
\code{exit()}.  Syntax and scanner errors are reported to standard error, but
the parser cannot usually recover from such errors and will cause a
\code{ParameterFile} instantiation to fail with a call to \code{exit}.

%See the section ``Known bugs and future enhancements'' for information on 
%how exception handling will be performed in future versions.

%\paragraph{Known bugs and future enhancements}

\paragraph{Examples}
Figure \ref{samplefile} shows a sample input file that is readable by the
\code{ParameterFile} parser.  Figures \ref{samplecode} shows a small sample
program that reads in some of these values.


\begin{figure}
\footnotesize
\begin{verbatim}
// This is a sample file to demonstrate the format readable by the
// ParamterFile object

// Parameters are enclosed in parentheses and take the form:
//
// (parameter_name optional_value1 optional_value2 .... optional_valueN)
//
// C++ style comments can be used.  Note C-style comments are NOT supported.
//

(bounding_box1 0 100 50 -50) (k .15)

(forsythia "the tree with the" "lights in it" "edgy" "2394 sljdkf09128 ...sdfk238"
"32ls lskdl 02302...&*&%$#!" "right now strings cannot be more"
"than VPF::MAXSTRLEN characters long" )

(flag_value)  // No parameter values is OK, too.

(mixed_types 0 "string_value" 34.2222 -0.987) // mixes types are OK, too

// SOME COMMENTS

(d 1.13425835)  // MORE COMMENTS
\end{verbatim}
\caption{sample.txt}
\label{samplefile}
\end{figure}

\begin{figure}
\footnotesize
\begin{verbatim}
#include <iostream.h>
#include "param.h"

main(int argc, char *argv[]) {
  int x1, x2, y1, y2;
  float k;
  double d;
  char string[VPF::MAXSTRLEN];
  VPF::ParameterFile F("sample.txt");

  if ( ! F.valid() ) { cerr << "Problems reading input file." << endl; exit(1); }
  if ( F.empty()   ) { cerr << "Input file is empty" << endl; exit(2); }
  
  if (F["bounding_box1"].valid() && F["bounding_box1"].size() == 4)
	{  if ( ! VPF::set(x1, F["bounding_box1"][0]) )
		cerr << "Argument 0 of \"bounding box\" is not an integer value" <<
		  endl;
	  if ( ! VPF::set(x2, F["bounding_box1"][1]) )
  		cerr << "Argument 1 of \"bounding box\" is not an integer value" <<
		  endl;
	  if ( ! VPF::set(y1, F["bounding_box1"][2]) )
  		cerr << "Argument 2 of \"bounding box\" is not an integer value" <<
		  endl;
	  if ( ! VPF::set(y2, F["bounding_box1"][3]) )
  		cerr << "Argument 3 of \"bounding box\" is not an integer value" <<
		  endl;
	}
  else
	{ cerr << "\"bounding_box1\" is not a valid parameter name" << endl;
	  exit(3);
	}
  // Set a floating point value
  if (F["k"].valid() && F["k"].size() > 0)
	{ if ( !VPF::set(k, F["k"][0]) )
	  cerr << "Argument 1 of \"k\" is not a decimal value" << endl;
	}
  else { cerr << "\"k\" is not a valid parameter name" << endl; }

  // Set a double value
  if (F["d"].valid() && F["d"].size() > 0)
	{ if ( !VPF::set(d, F["d"][0]) )
	  cerr << "Argument 1 of \"d\" is not a decimal value" << endl;
	}
  else { cerr << "\"d\" is not a valid parameter name" << endl; }

  // Set a string value.
  // Note that the string set function assumes a buffer of at least VPF::MAXSTRLEN
  // characters.
  
  if (F["forsythia"].valid() && F["forsythia"].size() > 4)
	{
	  if ( !VPF::set(string, F["forsythia"][3]) )
		cerr << "Argument 3 of \"forsythia\" is not a string value" <<endl;
	}
  else { cerr << "\"forsythia\" is not a valid parameter name" << endl; }
}
\end{verbatim}
\caption{example.C}
\label{samplecode}
\end{figure}

\end{document}
